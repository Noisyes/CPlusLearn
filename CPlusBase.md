# C++基础

## Day1

### 2  ::双冒号作用域运算符

全局作用域直接加::

### 3 namespace 命名空间

1. 用途 解决名称冲突问题
2. 必须在全局作用域下声明
3. 命名空间可以放入函数、变量、结构体、类
4. 命名空间可以嵌套命名空间
5. 命名空间是开放得，可以随时加入新得成员
6. 匿名命名空间 static
7. 可以起别名

### 4 using声明和using编译指令

1. using LOL::sunwukongID
2. 如果局部范围还有sunwukongID，会出现二义性问题，要注意避免
3. 编译指令： using namespace LOL
4. 如果局部范围还有sunwukongID，使用局部得ID
5. 如果打开多个房间，那么也要注意二义性

### 5 C++对C语言的增强

1. 全局变量检测的增强
2. 函数检测增强
   1. 参数类型检测
   2. 返回值检测
   3. 传参个数检测
3. 类型转换检测增强
   1. malloc返回void*，C中可以不用强转，c++必须强转
4. struct增强
   1. C中不许有函数 C++可以
   2. 使用c必须加关键字struct c++不用
5. bool数据类型增强
   1. c中没有 c++有
   2. sizeof值为1
6. 三目运算符增强
   1. c返回值
   2. c++返回变量
7. const 增强
   1. C语言中const修饰的变量，是伪常量，编译器是会分配内存的。C++中，const是不会分配内存的。
   2. C语言中默认const是外部链接，C++是默认内部链接。
   3. C++ const分配内存 取地址会分配临时内存
   4. extern 编译器也会给const变量分配内存
   5. C++用普通变量初始化const变量会分配内存，只要分配变量就可以改变const值。
   6. C++自定义数据类型 加const也会分配内存
   7. 尽量以const替换#define
      1. 宏没有作用域的概念
      2. define宏常量没有类型

### 6 引用的用法

1. 起别名

   `Type &p = a;`

2. 给数组起别名

   ```c++
   int arr[100];
   int (&parr)[100] = arr;
   typedef int (ARRAYREF)[10];
   ARRAYREF & parr2 = arr;
   ```

3. 引用必须初始化 初始化之后不能修改

4. 引用的本质：引用就是一个指针常量

   int& 转换wei int* const

5. 常量引用

   1. `const int &ref = 10//加入const后编译器处理方式为 int tmp =10;const int &ref = tmp `

    只要分配了新的内存，就可以通过指针绕过const修改值

   2. 常量引用使用场景：用来修饰形参、用一级指针引用可以代替二级指针

### 7  参数传递方式

1. 值传递
2. 地址传递
3. 引用传递
4. 注意事项
   1. 必须引用一块合法的内存空间（不能有NULL引用）
   2. 不要返回一个局部变量的引用
   3. 如果一个函数返回的是引用，那么这个函数可以作为左值。

## Day 2

### 类和对象的关系

​	类是对对象的抽象，对象是对类的实例。

### 内联函数

#### 宏函数的缺陷

```c++
#define Myadd(x,y) x+y
void test()
{
	int ret = Myadd(10,20) * 20//预期结果600 实际10+20*20
}
```

```c++
#define MyCompare(a,b) a<b?a:b
void test()
{
	int a = 10;
    int b = 20;
    int ret = MyCompare(++a,b);//预期跟实际不一样
}
```

* 宏函数也没有作用域,没有类型
* 宏函数目的：函数有压栈和出栈的开销

#### 内联函数的概念

`inline void func()`

* 注意事项：
  * `inline void func()`内联函数声明
  * `inline void func()`函数实现的时候也要加上inline
* 直接实现在类内部的成员函数，编译器默认加上inline
* 直接实现在类内部的成员函数即使加上了inline，也可能不会当作inline处理
  * 不存在任何循环语句
  * 不能存在过多的条件判断
  * 函数体不能过于庞大
  * 不能对函数进行取地址操作
* 内联只是对编译器的一个建议，编译器不一定会接受这种建议。

### 函数默认参数

* 参数可以有默认值

* 如果有一个位置有了默认参数，那么从这个位置开始，从左往后都必须有默认参数
* 函数声明有了默认参数，函数实现就没有。声明和实现只能有一个有默认参数，不要同时出现默认参数。
* 函数可以有占位参数，调用的时候必须提供。占位参数也可以有默认值，C语言里面没有默认参数。

### 函数重载

* 同一个作用域，函数签名不同，会发生函数重载。
* 函数签名（参数个数，参数类型，参数顺序，函数名）
* 当函数重载遇到默认参数，要注意避免二义性问题。
* 引用的重载版本
  * const可以作为函数重载的条件

#### 函数重载的实现原理

* 编译器可能将重载的函数在内部改名，以便内部识别，不同编译器有不同的命名方式。

### extren C浅析

* 在C++中调用C语言代码

* `ifdef __cplusplus extern "C"{}`

* `extern "C" void show()`

* ```c++
  extern "C"{
  
  }
  ```

### C和C++的封装区别

* C语言属性和行为分开处理了，类型检测弱。
* C++中的封装是严格的类型转换检测，让属性和行为绑定到一起
* C++中封装拥有访问权限
* struct 和class是一个意思，唯一的不同是默认权限不同。C++中class默认权限是private，struct默认权限是public。
* 建议将所有成员属性设置为私有，自己提供接口给外部。

## Day3

### 构造函数

* 没有返回值，没有void，类名相同，可以重载，可以有参数，作用域是public

#### 构造函数的分类和调用

* 分类
  * 按照参数进行分类
    * 有参构造函数
    * 默认构造函数
  * 按照类型进行分类
    * 普通构造函数
    * 拷贝构造函数 
* 调用
  * 括号法调用
  * 显式法调用  



### 析构函数

* 没有返回，没有void，函数名称：~类名，不可以发生重载，不可以有参数，作用域是public





