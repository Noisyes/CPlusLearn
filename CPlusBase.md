# C++基础

## Day1

### 2  ::双冒号作用域运算符

全局作用域直接加::

### 3 namespace 命名空间

1. 用途 解决名称冲突问题
2. 必须在全局作用域下声明
3. 命名空间可以放入函数、变量、结构体、类
4. 命名空间可以嵌套命名空间
5. 命名空间是开放得，可以随时加入新得成员
6. 匿名命名空间 static
7. 可以起别名

### 4 using声明和using编译指令

1. using LOL::sunwukongID
2. 如果局部范围还有sunwukongID，会出现二义性问题，要注意避免
3. 编译指令： using namespace LOL
4. 如果局部范围还有sunwukongID，使用局部得ID
5. 如果打开多个房间，那么也要注意二义性

### 5 C++对C语言的增强

1. 全局变量检测的增强
2. 函数检测增强
   1. 参数类型检测
   2. 返回值检测
   3. 传参个数检测
3. 类型转换检测增强
   1. malloc返回void*，C中可以不用强转，c++必须强转
4. struct增强
   1. C中不许有函数 C++可以
   2. 使用c必须加关键字struct c++不用
5. bool数据类型增强
   1. c中没有 c++有
   2. sizeof值为1
6. 三目运算符增强
   1. c返回值
   2. c++返回变量
7. const 增强
   1. C语言中const修饰的变量，是伪常量，编译器是会分配内存的。C++中，const是不会分配内存的。
   2. C语言中默认const是外部链接，C++是默认内部链接。
   3. C++ const分配内存 取地址会分配临时内存
   4. extern 编译器也会给const变量分配内存
   5. C++用普通变量初始化const变量会分配内存，只要分配变量就可以改变const值。
   6. C++自定义数据类型 加const也会分配内存
   7. 尽量以const替换#define
      1. 宏没有作用域的概念
      2. define宏常量没有类型

### 6 引用的用法

1. 起别名

   `Type &p = a;`

2. 给数组起别名

   ```c++
   int arr[100];
   int (&parr)[100] = arr;
   typedef int (ARRAYREF)[10];
   ARRAYREF & parr2 = arr;
   ```

3. 引用必须初始化 初始化之后不能修改

4. 引用的本质：引用就是一个指针常量

   int& 转换为 int* const

5. 常量引用

   1. `const int &ref = 10//加入const后编译器处理方式为 int tmp =10;const int &ref = tmp `

    只要分配了新的内存，就可以通过指针绕过const修改值

   2. 常量引用使用场景：用来修饰形参、用一级指针引用可以代替二级指针

### 7  参数传递方式

1. 值传递
2. 地址传递
3. 引用传递
4. 注意事项
   1. 必须引用一块合法的内存空间（不能有NULL引用）
   2. 不要返回一个局部变量的引用
   3. 如果一个函数返回的是引用，那么这个函数可以作为左值。

## Day 2

### 类和对象的关系

​	类是对对象的抽象，对象是对类的实例。

### 内联函数

#### 宏函数的缺陷

```c++
#define Myadd(x,y) x+y
void test()
{
	int ret = Myadd(10,20) * 20//预期结果600 实际10+20*20
}
```

```c++
#define MyCompare(a,b) a<b?a:b
void test()
{
	int a = 10;
    int b = 20;
    int ret = MyCompare(++a,b);//预期跟实际不一样
}
```

* 宏函数也没有作用域,没有类型
* 宏函数目的：函数有压栈和出栈的开销

#### 内联函数的概念

`inline void func()`

* 注意事项：
  * `inline void func()`内联函数声明
  * `inline void func()`函数实现的时候也要加上inline
* 直接实现在类内部的成员函数，编译器默认加上inline
* 直接实现在类内部的成员函数即使加上了inline，也可能不会当作inline处理
  * 不存在任何循环语句
  * 不能存在过多的条件判断
  * 函数体不能过于庞大
  * 不能对函数进行取地址操作
* 内联只是对编译器的一个建议，编译器不一定会接受这种建议。

### 函数默认参数

* 参数可以有默认值

* 如果有一个位置有了默认参数，那么从这个位置开始，从左往后都必须有默认参数
* 函数声明有了默认参数，函数实现就没有。声明和实现只能有一个有默认参数，不要同时出现默认参数。
* 函数可以有占位参数，调用的时候必须提供。占位参数也可以有默认值，C语言里面没有默认参数。

### 函数重载

* 同一个作用域，函数签名不同，会发生函数重载。
* 函数签名（参数个数，参数类型，参数顺序，函数名）
* 当函数重载遇到默认参数，要注意避免二义性问题。
* 引用的重载版本
  * const可以作为函数重载的条件

#### 函数重载的实现原理

* 编译器可能将重载的函数在内部改名，以便内部识别，不同编译器有不同的命名方式。

### extren C浅析

* 在C++中调用C语言代码

* `ifdef __cplusplus extern "C"{}`

* `extern "C" void show()`

* ```c++
  extern "C"{
  
  }
  ```

### C和C++的封装区别

* C语言属性和行为分开处理了，类型检测弱。
* C++中的封装是严格的类型转换检测，让属性和行为绑定到一起
* C++中封装拥有访问权限
* struct 和class是一个意思，唯一的不同是默认权限不同。C++中class默认权限是private，struct默认权限是public。
* 建议将所有成员属性设置为私有，自己提供接口给外部。

## Day3

### 构造函数

* 没有返回值，没有void，类名相同，可以重载，可以有参数，作用域是public

#### 构造函数的分类和调用

* 分类
  * 按照参数进行分类
    * 有参构造函数
    * 默认构造函数
  * 按照类型进行分类
    * 普通构造函数
    * 拷贝构造函数 
* 调用
  * 括号法调用
  * 显式法调用  
  * 隐式类型转换



### 析构函数

* 没有返回，没有void，函数名称：~类名，不可以发生重载，不可以有参数，作用域是public

### 拷贝构造函数

#### 调用时机

* 用已经创建好的对象初始化新的对象
* 以值传递的方式给函数参数传值
* 以值的方式返回局部对象
* release模式下会做一定的优化

#### 调用规则

* 当提供了有参构造函数，那么系统就不会给我们提供默认构造函数，但是系统会提供默认的拷贝构造函数。
* 默认拷贝构造函数进行简单的值拷贝
* 我们提供了拷贝构造函数，那么系统就不会提供其他构造函数了。

### 深拷贝和浅拷贝

#### 浅拷贝

* 默认提供的拷贝构造函数会进行简单的值拷贝，如果属性里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放堆区空间。

### 初始化列表的基本使用

```c++
class Person
{
	int ma;
	int mb;
	int mc;
	public:
		Person(int a,int b,int c):ma(a),mb(b),mc(c)
		{
			
		}
}
```

* 在构造函数后面加上：属性（值），属性（值）

### 类对象作为类成员

* 当类对象作为类的成员变量时候，构造顺序是先构造成员变量再构造类，析构顺序相反。

### explicit关键字作用

* 防止隐式类型转换 

### new运算符使用

#### malloc缺陷

1. 程序员必须确定长度
2. malloc返回void*指针，c++不允许void * 赋值给其他任何指针，必须强转。
3. malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。
4. 用户再使用对象之前必须记住对他初始化，构造函数不能显式调用初始化，用户可能忘记调用初始化函数。

#### new运算符和delete运算符

* 所有使用new操作符创建的对象，返回该类型的指针，并且在堆区开辟内存，同时调用了构造函数。

* new 对应 delete

* 当用void * 接受new出来的指针，会出现释放的问题。（无法释放指针）

* 通过new开辟数组，一定会调用默认构造函数，所以一定要提供默认构造。

* new person[10] 对应 delete [] person

  

## Day4

### 静态成员变量

* 静态成员变量在类内声明，类外初始化。
* 静态成员变量也是有权限的。
* 所有对象共享数据
* 编译阶段分配内存

### 静态函数

* 不可以访问普通成员变量，因为没有this指针。但是可以传参进来访问。
* 可以访问静态成员变量
* 静态函数也有权限
* 可以通过对象访问，也可以通过类名。

### 单例模式

* 目的 为了让类只有一个实例，实例也不需要手动释放
* 将默认构造和拷贝构造私有化
* 内部维护一个对象的静态指针，指针私有化
* 提供对外的访问接口

### 成员变量和成员函数分开存储

* 空类大小为1，每个实例的对象都有独一无二的地址，char维护这个地址。
* 非静态成员变量属于对象身上
* 非静态成员函数不属于对象身上

### this指针

* this指针指向被调用的成员函数的对象
* this指针并不是对象的一部分，不会影响sizeof的结果
* this指针永远指向当前的对象
* 解决命名冲突
* *this 可以返回对象本体
* 如果成员函数没有用到this，那么空指针就不会出问题。
* 如果成员函数用到this指针，注意判断this指针是否为空。

### 常函数和常对象

* 常函数不允许修改指针指向的对象
* mutable修饰的成员变量在常函数中依然能够修改
* 常对象不允许修改属性，常对象只能调用常函数
* 常函数修饰的是this 指针

### 友元

* 全局函数作友元
  * 全局函数声明写到类中用friend声明
* 让整个类作友元类
  * 友元类是单向的 不可传递
* 成员函数做友元函数

## Day 5

### 加号运算符重载

* 成员函数进行相加
* 全局函数相加
* 运算符可以进行重载，因为本质就是函数

### 左移运算符重载

* 重载左移运算符，一般不写在成员函数中。
* 不要随意乱用符号重载
* 内置数据类型的运算符不可以重载

```c++
ostream& operator<<(ostream& out,myclass &value)
{
    out<<value.member1<<value.member2<<endl;
}
```

### 前置后置递增运算符重载

```c++
Type& operator++()//前置
{
    
}
Type operator++(int) //后置
{
    
}
```

* 前置++和- -的效率可能会高一些（编译器没有专门优化的情况）

### 指针运算符重载

* 用来托管自定义类型的对象，让对象进行自动的释放

```c++
Type* operator->()
{
    return this->members;
}
//smartp->->member() 编译器优化为smartp->member
Type& operator *()
{
    return *(this->member);
}
```

### 赋值运算符重载

* 一个类默认创建默认构造、析构、拷贝、operator=赋值运算符
* 默认的赋值运算符进行简单的值拷贝,如果类中有指向堆区的指针，就需要深拷贝，重载赋值运算符。

```c++
Type& operator=(const Type& p)
{
    if(this->member != NULL)
    {
        delete[] this->member;
        this->member = NILL;
    }
    //进行赋值
    return this->member;
}
```

### []运算符重载

```c++
memberType& operator[](Type index)
{
    return (this->member)[index];
}
```

## Day 6

### 关系运算符重载

```c++
bool operator == (const Type& p)
{
    if(p.member == this->member)
    {
        return true;
    }
    return false;
}
```

```c++
bool operator != (const Type& p)
{
    if(p.member != this->member)
    {
        return true;
    }
    return false;
}
```

```c++
bool operator < (const Type& p)
{
    if(this->member < p.member)
    {
        return true;
    }
    return false;
}
```

```c++
bool operator <= (Type& p)
{
    if(this->member <= p.member)
    {
        return true;
    }
    return false;
}
```

### 函数调用运算符重载

```c++
Type operator()(Type text)
{
    //do something
}
classType instance;
instance(type);
classType()(type)//匿名对象
```

### 操作符重载总结

* 不要重载与&&和或运算符||，短路特性缺失

### 继承

* 派生类中会拥有基类的私有成员，只是访问不到。
* 子类不会继承父类的构造和析构和赋值运算符

* 子类创建对象时，先调用父类的构造 再调用子类的构造

#### 同名处理

* 子类和父类拥有同名的函数名和成员名，会同时拥有，子类会隐藏父类
* 如果子类和父类函数名称相同，子类会把父类所有同名版本隐藏起来，只能加上基类的作用域

#### 静态成员处理

* 静态成员可以继承，同名也会隐藏。
* 子类和父类同名，所有同名版本也会被隐藏

#### 多继承

* 多继承很容易发生二义性
* 解决菱形问题利用虚基类，子类会有vbptr虚基类指针 指向一个虚基类表，通过表找到偏移量，最后找到共有的基类。

## Day 7

### 多态

	* 父类引用或指针 指向子类对象

#### 多态分类

* 静态多态 函数重载
* 动态多态 虚函数 继承关系

#### 静态联编

* 地址早绑定 编译阶段绑定好地址

动态联编

* 地址晚绑定，运行时候绑定好地址

#### 多态原理解析

* 当父类中有了虚函数之后，内部结构就多了一个vfptr指向虚函数表
* 子类会继承vfptr 和vftable

* 对象创建的时候，调用构造函数时，将所有的虚函数表指针都指向自己的虚函数表，这个操作时对程序员透明的。
* 子类重写父类的虚函数时，将重写的函数替换到虚函数表中。

### 开闭原则

* 对扩展开放 对修改关闭

### 纯虚函数

* 父类中有纯虚函数，子类必须实现之后才能创建对象。
* 父类中有纯虚函数，父类无法实例化，也称为抽象类。
* 子类不实现纯虚函数，也是抽象类。

### 虚析构

* 父类普通析构函数不会调用子类的析构函数
* 虚析构解决这个问题 virtual ~ClassName(){}

### 纯虚析构

* 纯虚析构需要实现类内声明，类外实现。
* 那么函数中出现纯虚析构函数，那么这个类也是抽象类，不可实例化。

### 向上类型转换和向下类型转换

* 不发生多态
  * 向下不安全
  * 向上安全
* 发生多态
  * 总是安全的

## Day 8

### 函数模板

```c++
template <class T>
void func(T value1,T value2)
{
    
}

template<typename T>
void func(T value1,T value2)
{
    
}
```

* 区别:函数模板不可以进行隐式类型转换

#### 普通函数和函数模板调用规则

* 出现重载，优先使用普通函数。如果没有实现，出现错误。
* 如果想强制调用模板，可以使用空参数列表。`func<>(a,b)`
* 函数模板可以发生重载
* 如果函数模板可以产生更好的匹配，那么优先调用模板

### 模板的机制

* 模板不是万能的，不能通用所有的数据类型
* 模板不能直接调用，生成后的模板函数才可以
* 二次编译，第一次对模板进行编译，第二次对替换T类型之后的代码进行二次编译。
* 通过具体化自定义数据类型解决为题。
  * 如果具体化能够优先匹配，那么就选择具体化
  * template 返回值 函数名<具体类型>（参数列表）

### 类模板

* 不支持自动类型推导，只能显式指定类型
* 类模板可以默认参数
* 成员函数 一开始不会创建出来，而是在运行时创建

#### 类模板做函数的参数

1. 传入指定类型
2. 参数模板化
3. 整体模板化

### 类模板碰到继承的问题

* 子类继承模板类的时候必须告诉base中的T的类型，否则T无法分配
* 或者子类也写成一个模板类

### 模板类的类外实现

```c++
template<class T1,class T2>
 returnType  Myclass<T1,T2>::Func(T1 para1,T2 para2)
 {
     
 }
```

### 类模板的分文件编写问题

* 不要分文件编写,.h 和.cpp写到一个文件内，将后缀名改成.hpp
* 原因：类模板的成员函数在运行阶段才创建，导致包含.h文件，不会创建函数实现，无法解析外部命令

### 类模板碰到友元函数

* 友元函数类内实现
* 友元函数类外实现

## Day 9

### C++ 类型转换

#### 静态类型转换

* 向上安全，向下不安全

```c++
char a = 'a'
double d = static_cast<double>(a);
```

* static_cast<type>(instance)
* 自定义类型非父子关系无法进行转换

#### 动态类型转换

* 基础类型不可以转换
* dynamic_cast 非常严格，失去精度或者不安全都不可以进行转换
* dynamic_cast如果发生了多态 就可以进行向下类型转换

#### 常量转换

* 不能对非指针和非引用变量使用const_cast
* 给指针和引用加上const或者去除const

#### 重新解释转换（基本不使用）

### 异常

#### 栈解旋

* 从try开始到throw之前的所有栈上的对象都会被释放，这个过程被称为栈解旋

#### 异常接口声明

`void func()throw(int,char)`

#### 异常变量的生命周期

* 调用拷贝构造
* 引用
* 指针，早就释放了，但是仍然可以访问。但是现在是非法内存。

#### 异常的多态使用

* 利用多态，统一调用同一接口。抛出不同的错误提示

#### 系统标准异常

`#include<stdexcept>`

#### 编写自己的异常类

* 重写虚析构 和what（）

### c++输入输出流

##### 标准输入流

* cin.get(两个参数) 不会读取换行符
* cin.getline() 会读取换行符并且扔掉
* cin.ignore() 没有参数会忽略一个字符 带参数的可以规定忽略几个字符
* cin.peek()  会返回缓冲区中的第一个字符。
* cin.putback() 放回
* cin.clear()重置标志位和cin.sync()清空缓冲区
* cin.fail()错误标志

##### 标准输出流

* cout.put() 缓冲区写字符

* cout.write() 向buffer写num个字节到输出流中

* 格式化输出 `#include<iomanip>`

  * 控制符控制
  * 成员函数控制
### 文件输入输出流

#### 输出流

`ofstream ofs("",ios::out|ios::trunc);`

```c++
ofstream ofs;
ofs.open("path",ios::out|ios::trunc)
    if(!ofs.is_open)
    {
        
    }
```

#### 输入流

```c++
ifstream ifs;
ifs.open("path",ios::in);
if(!ifs.is_open())
{
    
}
//first
char buf[1024];
while(ifs>>buf) //按行输入
{
    cout<<buf<<endl;
}
//second
char buf2[1024];
while(!ifs.eof())//读到文件尾部
{
    ifs.getline(buf2,sizeof(buf2));
    cout<<buf2<<endl;
}
//three 单个字符读取 不推荐
char c;

```


